# pylint: disable=C0103
"""
This module provides the class ScaleReader. It can be used to read numeric
values from an image of a seven segment display.
"""

from PIL import Image  # type: ignore
from src.config_loader import ConfigLoader
from src.ocr import Ocr


class MissingInputImageError(Exception):
    """
    Indicate that None was passed to a function which relies on
    an input image.
    """


class MissingConfigLoaderError(Exception):
    """
    Indicate that None was provided where a valid ConfigLoader is mandatory.
    """


class ScaleReader:
    """
    The class ScaleReader can be used to read numeric values from an image of a
    seven segment display.

    This operation has 2 prerequisites:
        1. A sufficiently clear and high contrast image of the display.
        2. Calibration data specifying pixel values of the four corners of
            the seven-segment-display-region of the image. This data can relatively easily be
            obtained using the calibration script inside of the project folder
    The code assumes:
        1. That the numbers in the image have a strong red hue compared to the rest of the image
        2. That the image shows 3 digits

    """
    def __init__(self, config_loader: ConfigLoader) -> None:
        """
        The input image is provided through the constructor
        ! Calibration needs to be done using the same image dimensions !
        """
        if config_loader is None:
            raise MissingConfigLoaderError

        self.config_loader = config_loader
        self.region_of_interest = None
        self.image = None
        self.red_mask = None
        self.resize_factor = 4

    def readWeight(self, image: Image) -> float:
        """
        Prepare the image for OCR.
        Then perform OCR and sanitize its output.
        """
        if image is None:
            raise MissingInputImageError
        self.image = image

        self.prepare_lcd_region_of_interest()

        (readout, _) = Ocr.read(image=self.red_mask)
        readout = str(readout)

        # Assume the point is at the 3rd position of the readout
        weight = readout[2:4] + '.' + readout[4]

        return weight

    def prepare_lcd_region_of_interest(self):
        """
        Transform the image to isolate the region containing the display.
        The values specifying the four corners of the display are read from
        a config file and can be generated by running 'calibration.py'.
        Further, the image is downsized to speed up processing.
        """
        config = self.config_loader.getConfig()

        lcd_redgion = self.image.transform(self.image.size, Image.QUAD, [
            config['northwest']['x'], config['northwest']['y'],
            config['southwest']['x'], config['southwest']['y'],
            config['southeast']['x'], config['southeast']['y'],
            config['northeast']['x'], config['northeast']['y']
        ], Image.BILINEAR)

        (width, height) = lcd_redgion.size
        small_size = (width // self.resize_factor,
                      height // self.resize_factor)
        lcd_redgion.resize(small_size)

        self.region_of_interest = lcd_redgion

    def isolate_red_pixels(self):
        """
        Try to isolate red pixels. Generate a 1bit image where
        a value of 1 means 'above a certain ratio of red to other colors' and
        a value of 0 measns 'below that ratio'
        """
        self.red_mask = Image.new('1', self.region_of_interest.size)

        for x in range(self.region_of_interest.size[0]):
            for y in range(self.region_of_interest.size[1]):

                pixel = self.region_of_interest.getpixel((x, y))
                red = pixel[0]
                green = pixel[1]
                blue = pixel[2]

                redProportion = max(0, (red - (green + blue)))

                if redProportion > 10:
                    self.red_mask.putpixel((x, y), 1)
                else:
                    self.red_mask.putpixel((x, y), 0)
